	macro&lbl	mul38.* pass value to multiply in C, result returned in HL.* destroys B,C,H,L&lbl	ld	B,0		; limit product to 255*38	sla	C		; BC << 1	rl	B	ld	H,B		; HL <- BC  (HL = BC * 2)	ld	L,C	sla	C		; BC << 1	rl	B	zadd	HL,BC		; HL += BC  (HL = BC * 6)	sla	C		; BC << 1	rl	B	sla	C		; BC << 1	rl	B	sla	C		; BC << 1	rl	B	zadd	HL,BC		; HL += BC  (HL = BC * 38)	endm	macro&lbl	mul6.* pass value to multiply in C, result returned in HL.* destroys B,C,H,L&lbl	ld	L,C		; HL <- 0C	ld	H,0	zadd	HL,HL		; HL += HL (HL = Li * 2)	ld	B,H		; BC <- HL	ld	C,L	zadd	HL,HL		; HL += HL (HL = Li * 4)	zadd	HL,BC		; HL += (HL * 2)	endm* Requires H = data, L = register number	macro&lbl	FMwrgl.*&lbl	bit	7,(IY+0)	; test fm chip status	jr	NZ,*-4		; wait for clear	ld	A,L	ld	(4000H),A	; write global register number	ld	A,H	ld	(4001H),A	; write data	endm                    ; done	macro&lbl	FMwait.*&lbl	bit	7,(IY+0)	; test fm chip status	jr	NZ,*-4		; wait for clear	endm                    ; done* FMWrite and FMWrch expect IY to contain either 4000H or 4002H* destroys A	macro&lbl	FMWrite	&reg,&data.*&lbl	ld	A,&data		; load data	bit	7,(IY+0)	; test fm chip status	jr	NZ,*-4		; wait for clear	ld	(IY+0),&reg	; write register number	ld	(IY+1),A	; write data	endm			; done* destroys A	macro&lbl	FMWrch	&reg,&ch,&data.*&lbl	bit	7,(IY+0)	; test fm chip status	jr	NZ,*-4		; wait for clear	ld	A,&ch		; load channel number	zadd	A,&reg		; add register number	ld	(IY+0),A	; write register number	ld	A,&data		; load data	ld	(IY+1),A	; write data	endm			; done		macro&lbl		FMWr	&reg,&data.*&lbl		ld	L,0		; point initially at status register		ld	A,&reg		; get reg num for this channel		zadd	A,E		ld	B,A		; B <- register number (parameter) offset for this channel		ld	C,&data		ld	A,80H		; mask for busy bit				zand	(HL)		; test fm chip status		jp	M,*-2		; still busy - wait for clear				ld	L,D		; point at appropriate bank		ld	(HL),B		; write regnum		inc	L		; point to data		ld	(HL),C		; write data				endm			; done					macro&lbl	db	  LCLA	&i	  GBLC	&isnum	  GBLC	&numconvert.*&lbl	  &i:	SETA	1	  WHILE (&SYSLIST[&i] <> '') DO	    CVTNUM	&SYSLIST[&i]	    IF (&isnum = '1') THEN	dc.b	&numconvert	    ELSE	dc.b	&SYSLIST[&i]	    ENDIF	    &i:	SETA	&i + 1	  ENDWHILE	endm*	macro&lbl	dw	  LCLA	&i	  GBLC	&isnum	  GBLC	&numconvert.*&lbl	  &i:	SETA	1	  WHILE (&SYSLIST[&i] <> '') DO	    CVTNUM	&SYSLIST[&i]	    IF (&isnum = '1') THEN	dc.b	&numconvert AND $0FF	dc.b	(&numconvert >> 8) AND $0FF	    ELSE	dc.b	(&SYSLIST[&i]-Z80CodeBase) AND $0FF	dc.b	((&SYSLIST[&i]-Z80CodeBase) >> 8) AND $0FF	    ENDIF	    &i:	SETA	&i + 1	  ENDWHILE	endm*	macro&lbl	dl	  LCLA	&i	  GBLC	&isnum	  GBLC	&numconvert.*&lbl	  &i:	SETA	1	  WHILE (&SYSLIST[&i] <> '') DO	    CVTNUM	&SYSLIST[&i]	    IF (&isnum = '1') THEN	dc.b	&numconvert AND $0FF	dc.b	(&numconvert >> 8) AND $0FF	dc.b	(&numconvert >> 16) AND $0FF	dc.b	(&numconvert >> 24) AND $0FF	    ELSE	dc.b	(&SYSLIST[&i]-Z80CodeBase) AND $0FF	dc.b	((&SYSLIST[&i]-Z80CodeBase) >> 8) AND $0FF	dc.b	((&SYSLIST[&i]-Z80CodeBase) >> 16) AND $0FF	dc.b	((&SYSLIST[&i]-Z80CodeBase) >> 24) AND $0FF	    ENDIF	    &i:	SETA	&i + 1	  ENDWHILE	endm